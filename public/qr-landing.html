<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Videollamada Directa</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #7d1522, #3d3d3d);
        color: white;
        text-align: center;
        padding: 20px;
        min-height: 100vh;
      }
      .container {
        max-width: 100%;
      }
      h1 {
        margin: 20px 0;
        font-size: 24px;
      }
      .video-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin: 20px 0;
      }
      video {
        width: 100%;
        max-width: 400px;
        height: 300px;
        border-radius: 15px;
        background: #000;
        transform: scaleX(-1);
        object-fit: cover;
      }
      #localVideo {
        transform: scaleX(-1);
      }
      .button {
        background: #faffff;
        color: #7d1522;
        border: none;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 10px;
        cursor: pointer;
        margin: 10px;
        font-weight: bold;
        transition: opacity 0.2s;
      }
      .button:hover {
        opacity: 0.9;
      }
      .end-call {
        background: #dc3545;
        color: white;
      }
      .status {
        margin: 20px 0;
        padding: 15px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.2);
        font-size: 16px;
      }
      .notification-badge {
        background: #28a745;
        color: white;
        padding: 10px 15px;
        border-radius: 20px;
        margin: 10px 0;
        display: inline-block;
        font-size: 14px;
      }
      .error {
        background: #dc3545 !important;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Videollamada Directa</h1>

      <div id="notificationStatus" class="notification-badge" style="display: none">
        Notificando al host...
      </div>

      <div id="status" class="status">Iniciando videollamada...</div>

      <div class="video-container">
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>

      <button id="endCallButton" class="button end-call" style="display: none">
        Colgar Llamada
      </button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      // âœ… VARIABLES GLOBALES (FALTABAN)
      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const status = document.getElementById("status");
      const notificationStatus = document.getElementById("notificationStatus");
      const endCallButton = document.getElementById("endCallButton");

      let localStream = null;
      let peerConnection = null;
      let socket = null;
      let callId = null;
      let hostId = null;

      // âœ… CONFIGURACIÃ“N ICE
      const pcConfig = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
        ],
      };

      // âœ… INICIALIZAR AL CARGAR LA PÃGINA
      window.addEventListener("load", async () => {
        await initializeCall();
      });

      async function initializeCall() {
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const qrCode = urlParams.get("code");

          if (!qrCode) {
            status.textContent = "Error: CÃ³digo QR no vÃ¡lido";
            return;
          }

          status.textContent = "Activando cÃ¡mara y micrÃ³fono...";

          // âœ… OBTENER HOST INFO Y CREAR LLAMADA
          const hostInfo = await getHostInfo(qrCode);
          
          const callResponse = await fetch("/videocall/anonymous-call", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              qrCode: qrCode,
              guestName: "Visitante Web",
            }),
          });

          const callData = await callResponse.json();

          if (!callData.success) {
            throw new Error(callData.error || "Error creando llamada");
          }

          // âœ… USAR EL callId REAL
          callId = callData.callId;
          hostId = callData.hostId;

          console.log("âœ… Call ID real:", callId);
          console.log("âœ… Host ID:", hostId);

          // OBTENER MEDIA
          localStream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
              facingMode: "user",
            },
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          localVideo.srcObject = localStream;
          status.textContent = "CÃ¡mara activada - Conectando...";

          // CONECTAR SOCKET
          socket = io("https://videoporteroqr-back.onrender.com", {
            transports: ["websocket"],
            secure: true,
          });

          setupSocketEvents();

          // âœ… UNIRSE A LA SALA CON EL callId CORRECTO
          socket.emit("join-call-room", {
            callId: callId,
            userType: "guest",
            userId: "web-guest-" + Date.now(),
          });

          // NOTIFICAR AL HOST
          await sendNotificationToHost();

        } catch (err) {
          console.error("Error inicial:", err);
          status.textContent = `Error: ${err.message || "Permisos denegados"}`;
        }
      }

      async function getHostInfo(qrCode) {
        try {
          const res = await fetch(`/auth/host-by-qr/${qrCode}`);
          if (!res.ok) throw new Error("Host no encontrado");
          const data = await res.json();
          return data.host;
        } catch (err) {
          console.error("Error obteniendo host:", err);
          throw err;
        }
      }

      async function sendNotificationToHost() {
        if (!hostId) return;
        
        notificationStatus.style.display = "block";
        notificationStatus.textContent = "Notificando al host...";

        // NotificaciÃ³n por Socket.io
        socket.emit("call-host", {
          hostId,
          call: {
            _id: callId, // âœ… Usar el mismo callId
            guestName: "Visitante Web",
            guestEmail: "web@visitante.com",
            hostId,
            createdAt: new Date().toISOString(),
            status: "pending",
            isWebGuest: true,
          },
        });

        notificationStatus.textContent = "Host notificado - Esperando...";
      }

      function setupSocketEvents() {
        socket.on("connect", () => {
          console.log("Conectado al servidor");
          status.textContent = "Llamando al host...";
        });

        // âœ… EVENTOS NUEVOS PARA SALA COMPARTIDA
        socket.on("host-ready", (data) => {
          console.log("âœ… Host listo en la sala:", data);
          status.textContent = "Host conectado - Iniciando videollamada...";
          initiateWebRTC();
        });

        socket.on("call-connected", (data) => {
          console.log("âœ… ConexiÃ³n establecida con host:", data);
          status.textContent = "Videollamada conectada";
          notificationStatus.textContent = "Conectado con el host";
          notificationStatus.style.backgroundColor = "#28a745";
          endCallButton.style.display = "block";
        });

        socket.on("start-webrtc", (data) => {
          console.log("ðŸŽ¯ Iniciando WebRTC...");
          initiateWebRTC();
        });

        // âœ… WEBRTC EVENTOS (EXISTENTES)
        socket.on("offer", async (data) => {
          console.log("Offer recibida del host");
          if (!peerConnection) await initiateWebRTC();
          try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit("answer", {
              answer,
              callId,
              userType: "guest",
            });
          } catch (e) {
            console.error("Error procesando offer:", e);
          }
        });

        socket.on("answer", async (data) => {
          console.log("Answer recibida");
          if (peerConnection && !peerConnection.remoteDescription) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
          }
        });

        socket.on("ice-candidate", async (data) => {
          if (data.userType === "host" && data.candidate && peerConnection) {
            try {
              await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (e) {
              console.log("ICE candidate ignorado:", e);
            }
          }
        });

        socket.on("call-ended", () => {
          status.textContent = "Llamada finalizada por el host";
          endCall();
        });

        socket.on("disconnect", () => {
          status.textContent = "ConexiÃ³n perdida";
        });
      }

      async function initiateWebRTC() {
        if (peerConnection) return;
        
        status.textContent = "Estableciendo conexiÃ³n segura...";
        peerConnection = new RTCPeerConnection(pcConfig);

        // AÃ±adir tracks locales
        localStream.getTracks().forEach((track) => {
          peerConnection.addTrack(track, localStream);
        });

        // Recibir stream del host
        peerConnection.ontrack = (event) => {
          console.log("Stream del host recibido");
          remoteVideo.srcObject = event.streams[0];
          status.textContent = "Videollamada activa";
        };

        // Enviar ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit("ice-candidate", {
              candidate: event.candidate,
              callId,
              userType: "guest",
            });
          }
        };

        // Crear y enviar offer
        try {
          const offer = await peerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
          });
          
          await peerConnection.setLocalDescription(offer);
          
          socket.emit("offer", {
            offer,
            callId,
            userType: "guest",
          });
          
          console.log("Offer enviada al host");
          status.textContent = "Conectando con el host...";
        } catch (e) {
          console.error("Error creando offer:", e);
          status.textContent = "Error de conexiÃ³n";
        }
      }

      function endCall() {
        status.textContent = "Finalizando llamada...";
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
        if (localStream) {
          localStream.getTracks().forEach((t) => t.stop());
          localStream = null;
        }
        if (socket) {
          socket.emit("end-call", { callId });
          socket.disconnect();
          socket = null;
        }
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        endCallButton.style.display = "none";
        notificationStatus.style.display = "none";
        status.textContent = "Llamada finalizada";
        setTimeout(() => window.close(), 3000);
      }

      // âœ… EVENT LISTENERS (FALTABAN)
      endCallButton.addEventListener("click", endCall);

      window.addEventListener("beforeunload", () => {
        if (socket) socket.emit("end-call", { callId });
      });
    </script>
  </body>
</html>