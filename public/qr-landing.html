<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Videollamada Directa</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: linear-gradient(135deg, #7d1522, #3d3d3d);
            color: white; text-align: center; padding: 20px;
        }
        .container { max-width: 100%; }
        h1 { margin: 20px 0; }
        .video-container { 
            display: flex; flex-wrap: wrap; justify-content: center; 
            gap: 20px; margin: 20px 0;
        }
        video { 
            width: 100%; max-width: 400px; height: 300px; 
            border-radius: 15px; background: #000; transform: scaleX(-1);
        }
        .button { 
            background: #faffff; color: #7d1522; border: none; 
            padding: 15px 30px; font-size: 18px; border-radius: 10px; 
            cursor: pointer; margin: 10px; font-weight: bold;
        }
        .button:hover { opacity: 0.9; }
        .end-call { background: #dc3545; color: white; }
        .status { 
            margin: 20px 0; padding: 15px; border-radius: 10px; 
            background: rgba(255, 255, 255, 0.2);
        }
        .notification-badge {
            background: #28a745;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            margin: 10px 0;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¥ Videollamada Directa</h1>

        <div id="notificationStatus" class="notification-badge" style="display: none;">
            ðŸ”” Notificando al host...
        </div>

        <div id="status" class="status">Iniciando videollamada...</div>

        <div class="video-container">
            <video id="localVideo" autoplay muted playsinline></video>
            <video id="remoteVideo" autoplay playsinline></video>
        </div>

        <button id="endCallButton" class="button end-call" style="display: none">
            ðŸ“ž Colgar Llamada
        </button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Elementos DOM
        const localVideo = document.getElementById("localVideo");
        const remoteVideo = document.getElementById("remoteVideo");
        const status = document.getElementById("status");
        const notificationStatus = document.getElementById("notificationStatus");
        const endCallButton = document.getElementById("endCallButton");

        // Variables WebRTC
        let localStream = null;
        let peerConnection = null;
        let socket = null;
        let roomId = null;
        let hostId = null;

        // ConfiguraciÃ³n ICE Servers
        const pcConfig = {
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
            ],
        };

        // Inicializar al cargar la pÃ¡gina
        window.addEventListener("load", async () => {
            await initializeCall();
        });

        async function initializeCall() {
            try {
                status.textContent = "ðŸŽ¥ Activando cÃ¡mara y micrÃ³fono...";

                // 1. Obtener cÃ³digo QR de la URL
                const urlParams = new URLSearchParams(window.location.search);
                const qrCode = urlParams.get("code");

                if (!qrCode) {
                    status.textContent = "âŒ Error: CÃ³digo QR no vÃ¡lido";
                    return;
                }

                roomId = qrCode; // Usamos el QR code como room ID

                // âœ… NUEVO: Obtener informaciÃ³n del host desde el backend
                await getHostInfo(qrCode);

                // 2. Obtener stream de medios
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: "user",
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100,
                    },
                });

                // 3. Mostrar video local
                localVideo.srcObject = localStream;
                status.textContent = "âœ… CÃ¡mara activada - Conectando...";

                // 4. Conectar al servidor Socket.io
                socket = io("https://videoporteroqr-back.onrender.com", {
                    transports: ["websocket"],
                });

                // 5. Configurar eventos del socket
                setupSocketEvents();

                // 6. Unirse a la sala
                socket.emit("join-room", { roomId, role: "guest" });

                // âœ… NUEVO: Enviar notificaciÃ³n automÃ¡tica al host
                await sendNotificationToHost();

                // 7. Iniciar WebRTC despuÃ©s de 2 segundos
                setTimeout(() => initiateWebRTC(), 2000);

            } catch (error) {
                console.error("Error inicial:", error);
                status.textContent = `âŒ Error: ${error.message}`;
            }
        }

        // âœ… NUEVA FUNCIÃ“N: Obtener informaciÃ³n del host
        async function getHostInfo(qrCode) {
            try {
                console.log("ðŸ” Buscando informaciÃ³n del host para QR:", qrCode);
                
                const response = await fetch(`/auth/get-host-by-qr?code=${qrCode}`);
                if (!response.ok) {
                    throw new Error('Host no encontrado');
                }
                
                const data = await response.json();
                hostId = data.hostId;
                console.log("âœ… Host encontrado:", data.hostName, "ID:", hostId);
                
            } catch (error) {
                console.error("âŒ Error obteniendo informaciÃ³n del host:", error);
                // Continuamos aunque falle, pero no podremos notificar al host
            }
        }

        // âœ… NUEVA FUNCIÃ“N: Enviar notificaciÃ³n al host
        async function sendNotificationToHost() {
            if (!hostId) {
                console.log("âŒ No se pudo obtener hostId, saltando notificaciÃ³n");
                return;
            }

            try {
                console.log("ðŸ”” Enviando notificaciÃ³n al host:", hostId);
                
                // Mostrar estado de notificaciÃ³n
                notificationStatus.style.display = 'block';
                notificationStatus.textContent = "ðŸ”” Notificando al host...";
                
                // Enviar notificaciÃ³n via Socket.io
                socket.emit('call-host', {
                    hostId: hostId,
                    call: {
                        _id: `web-call-${Date.now()}`,
                        guestName: 'Visitante Web',
                        guestEmail: 'web@visitante.com', 
                        hostId: hostId,
                        createdAt: new Date().toISOString(),
                        status: 'pending',
                        isWebGuest: true // Identificar que viene de la web
                    }
                });

                console.log("âœ… NotificaciÃ³n enviada al host via Socket.io");

                // TambiÃ©n enviar notificaciÃ³n via API (como backup)
                try {
                    const response = await fetch('/videocall/anonymous-call', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            qrCode: roomId,
                            guestName: "Visitante Web"
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log("âœ… NotificaciÃ³n API enviada:", data);
                        notificationStatus.textContent = "âœ… Host notificado - Esperando respuesta...";
                    }
                } catch (apiError) {
                    console.error("âŒ Error en notificaciÃ³n API:", apiError);
                }

            } catch (error) {
                console.error("âŒ Error enviando notificaciÃ³n:", error);
                notificationStatus.textContent = "âŒ Error notificando al host";
                notificationStatus.style.backgroundColor = '#dc3545';
            }
        }

        function setupSocketEvents() {
            socket.on("connect", () => {
                console.log("âœ… Conectado al servidor");
                status.textContent = "ðŸ”” Llamando al host...";
            });

            socket.on("call-accepted", () => {
                console.log("âœ… Llamada aceptada por el host");
                status.textContent = "âœ… Conectado con el host";
                notificationStatus.textContent = "âœ… Host ha aceptado la llamada";
                notificationStatus.style.backgroundColor = '#28a745';
                endCallButton.style.display = "block";
            });

            socket.on("call-rejected", () => {
                console.log("âŒ Llamada rechazada por el host");
                status.textContent = "âŒ Llamada rechazada por el host";
                notificationStatus.textContent = "âŒ Host ha rechazado la llamada";
                notificationStatus.style.backgroundColor = '#dc3545';
            });

            socket.on("answer", async (data) => {
                console.log("ðŸ“¨ Answer recibido");
                if (peerConnection) {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(data.answer)
                    );
                }
            });

            socket.on("ice-candidate", async (data) => {
                console.log("ðŸ§Š ICE candidate recibido");
                if (peerConnection) {
                    await peerConnection.addIceCandidate(
                        new RTCIceCandidate(data.candidate)
                    );
                }
            });

            socket.on("call-ended", () => {
                status.textContent = "ðŸ“ž Llamada finalizada por el host";
                notificationStatus.textContent = "ðŸ“ž Llamada finalizada";
                endCall();
            });

            socket.on("disconnect", () => {
                status.textContent = "âŒ ConexiÃ³n perdida";
            });
        }

        async function initiateWebRTC() {
            try {
                status.textContent = "ðŸ”— Estableciendo conexiÃ³n WebRTC...";

                // Crear peer connection
                peerConnection = new RTCPeerConnection(pcConfig);

                // AÃ±adir stream local
                localStream.getTracks().forEach((track) => {
                    peerConnection.addTrack(track, localStream);
                });

                // Manejar stream remoto
                peerConnection.ontrack = (event) => {
                    console.log("ðŸ“¹ Stream remoto recibido");
                    remoteVideo.srcObject = event.streams[0];
                    status.textContent = "âœ… Videollamada conectada";
                };

                // Manejar ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit("ice-candidate", {
                            candidate: event.candidate,
                            to: roomId,
                        });
                    }
                };

                // Crear y enviar offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                socket.emit("call-offer", {
                    offer: offer,
                    roomId: roomId,
                });

                console.log("âœ… Offer WebRTC enviado");
            } catch (error) {
                console.error("Error WebRTC:", error);
                status.textContent = "âŒ Error en conexiÃ³n WebRTC";
            }
        }

        function endCall() {
            status.textContent = "ðŸ“ž Finalizando llamada...";

            // Cerrar conexiones
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            if (localStream) {
                localStream.getTracks().forEach((track) => track.stop());
                localStream = null;
            }

            if (socket) {
                socket.emit("end-call", { roomId });
                socket.disconnect();
                socket = null;
            }

            // Limpiar videos
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;

            endCallButton.style.display = "none";
            status.textContent = "Llamada finalizada";

            // Redirigir despuÃ©s de 3 segundos
            setTimeout(() => {
                window.close();
            }, 3000);
        }

        // Evento para el botÃ³n de colgar
        endCallButton.addEventListener("click", endCall);

        // Manejar cierre de pÃ¡gina
        window.addEventListener("beforeunload", () => {
            if (socket) {
                socket.emit("end-call", { roomId });
            }
        });
    </script>
</body>
</html>