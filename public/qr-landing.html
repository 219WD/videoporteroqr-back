<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Videollamada Directa</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #7d1522, #3d3d3d);
        color: white;
        text-align: center;
        padding: 20px;
        min-height: 100vh;
      }
      .container {
        max-width: 100%;
      }
      h1 {
        margin: 20px 0;
        font-size: 24px;
      }
      .video-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin: 20px 0;
      }
      video {
        width: 100%;
        max-width: 400px;
        height: 300px;
        border-radius: 15px;
        background: #000;
        transform: scaleX(-1);
        object-fit: cover;
      }
      #localVideo {
        transform: scaleX(-1);
      }
      .button {
        background: #faffff;
        color: #7d1522;
        border: none;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 10px;
        cursor: pointer;
        margin: 10px;
        font-weight: bold;
        transition: opacity 0.2s;
      }
      .button:hover {
        opacity: 0.9;
      }
      .end-call {
        background: #dc3545;
        color: white;
      }
      .status {
        margin: 20px 0;
        padding: 15px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.2);
        font-size: 16px;
      }
      .notification-badge {
        background: #28a745;
        color: white;
        padding: 10px 15px;
        border-radius: 20px;
        margin: 10px 0;
        display: inline-block;
        font-size: 14px;
      }
      .error {
        background: #dc3545 !important;
      }
      .message-box {
        background: rgba(0, 0, 0, 0.7);
        border-radius: 10px;
        padding: 20px;
        margin: 20px auto;
        max-width: 500px;
        display: none;
      }
      .message-box textarea {
        width: 100%;
        height: 100px;
        margin: 10px 0;
        padding: 10px;
        border-radius: 5px;
        border: none;
        resize: none;
      }
      .message-box button {
        background: #28a745;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        margin: 5px;
      }
      .message-box button.reject {
        background: #dc3545;
      }
      .waiting-message {
        background: rgba(255, 193, 7, 0.2);
        border-left: 4px solid #ffc107;
        padding: 15px;
        margin: 15px 0;
        text-align: left;
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Videollamada Directa</h1>

      <div id="notificationStatus" class="notification-badge" style="display: none">
        Notificando al host...
      </div>

      <div id="status" class="status">Iniciando videollamada...</div>

      <!-- Mensaje de espera para cuando el host rechace -->
      <div id="waitingMessage" class="waiting-message">
        <h3>üìù ¬øQuieres dejar un mensaje?</h3>
        <p>El host no est√° disponible en este momento. Puedes dejar un mensaje y te contactaremos luego.</p>
        <textarea id="guestMessage" placeholder="Escribe tu mensaje aqu√≠..."></textarea>
        <button onclick="sendMessageToHost()">üì§ Enviar Mensaje</button>
        <button onclick="closePage()" class="reject">‚ùå Cerrar</button>
      </div>

      <div class="video-container">
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>

      <button id="endCallButton" class="button end-call" style="display: none">
        Colgar Llamada
      </button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      // ‚úÖ VARIABLES GLOBALES
      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const status = document.getElementById("status");
      const notificationStatus = document.getElementById("notificationStatus");
      const endCallButton = document.getElementById("endCallButton");
      const waitingMessage = document.getElementById("waitingMessage");

      let localStream = null;
      let peerConnection = null;
      let socket = null;
      let callId = null;
      let hostId = null;
      let hostName = null;
      let isCallActive = false;
      let isHostResponded = false;
      let connectionAttempts = 0;
      const MAX_CONNECTION_ATTEMPTS = 3;

      // ‚úÖ CONFIGURACI√ìN ICE MEJORADA
      const pcConfig = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" },
          { urls: "stun:stun3.l.google.com:19302" },
          { urls: "stun:stun4.l.google.com:19302" }
        ],
        iceCandidatePoolSize: 10
      };

      // ‚úÖ INICIALIZAR AL CARGAR LA P√ÅGINA
      window.addEventListener("load", async () => {
        await initializeCall();
      });

      async function initializeCall() {
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const qrCode = urlParams.get("code");

          if (!qrCode) {
            status.textContent = "Error: C√≥digo QR no v√°lido";
            showError("No se encontr√≥ c√≥digo QR en la URL");
            return;
          }

          status.textContent = "Activando c√°mara y micr√≥fono...";

          // ‚úÖ 1. OBTENER INFORMACI√ìN DEL HOST
          const hostInfo = await getHostInfo(qrCode);
          if (!hostInfo) {
            throw new Error("No se pudo obtener informaci√≥n del host");
          }

          hostName = hostInfo.name;
          hostId = hostInfo.id;

          console.log(`‚úÖ Host encontrado: ${hostName} (ID: ${hostId})`);

          // ‚úÖ 2. CREAR LLAMADA AN√ìNIMA EN EL BACKEND
          status.textContent = "Creando llamada...";
          const callResponse = await fetch("/videocall/anonymous-call", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              qrCode: qrCode,
              guestName: "Visitante Web",
            }),
          });

          const callData = await callResponse.json();

          if (!callData.success) {
            throw new Error(callData.error || "Error creando llamada");
          }

          // ‚úÖ 3. GUARDAR DATOS DE LA LLAMADA
          callId = callData.callId;
          console.log("‚úÖ Call ID creado:", callId);
          console.log("‚úÖ Host ID:", hostId);

          // ‚úÖ 4. OBTENER MEDIA (C√ÅMARA Y MICR√ìFONO)
          try {
            localStream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: "user",
                frameRate: { ideal: 30 }
              },
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: 44100,
                channelCount: 1
              }
            });

            localVideo.srcObject = localStream;
            status.textContent = "C√°mara activada - Conectando con el host...";
          } catch (mediaError) {
            console.warn("No se pudo acceder a c√°mara/micr√≥fono:", mediaError);
            status.textContent = "Conectando con el host (sin c√°mara)...";
            // Continuar sin media
          }

          // ‚úÖ 5. CONECTAR AL WEBSOCKET
          connectWebSocket();

          // ‚úÖ 6. NOTIFICAR AL HOST
          await sendNotificationToHost();

          // ‚úÖ 7. INICIAR POLLING PARA VERIFICAR ESTADO
          startCallStatusPolling();

        } catch (err) {
          console.error("Error inicial:", err);
          status.textContent = `Error: ${err.message}`;
          showError(err.message);
        }
      }

      async function getHostInfo(qrCode) {
        try {
          const res = await fetch(`/auth/host-by-qr/${qrCode}`);
          if (!res.ok) throw new Error("Host no encontrado");
          const data = await res.json();
          return data.host;
        } catch (err) {
          console.error("Error obteniendo host:", err);
          throw err;
        }
      }

      function connectWebSocket() {
        // Conectar al WebSocket del backend
        const socketUrl = window.location.hostname === 'localhost' 
          ? 'http://localhost:5000' 
          : 'https://videoporteroqr-back.onrender.com';
        
        socket = io(socketUrl, {
          transports: ["websocket", "polling"],
          reconnection: true,
          reconnectionAttempts: 5,
          reconnectionDelay: 1000
        });

        setupSocketEvents();
      }

      async function sendNotificationToHost() {
        if (!hostId || !callId) return;
        
        notificationStatus.style.display = "block";
        notificationStatus.textContent = "Notificando al host...";

        try {
          // Enviar notificaci√≥n por WebSocket
          socket.emit("call-host", {
            hostId,
            call: {
              _id: callId,
              guestName: "Visitante Web",
              guestEmail: "web@visitante.com",
              hostId,
              createdAt: new Date().toISOString(),
              status: "pending",
              isWebGuest: true,
              isAnonymous: true
            }
          });

          notificationStatus.textContent = "Llamando al host...";
          
          // Tambi√©n unirse a la sala de la llamada
          socket.emit("join-call-room", {
            callId: callId,
            userId: "web-guest-" + Date.now(),
            userRole: "guest"
          });

          console.log(`üìû Llamando al host ${hostName}...`);

        } catch (error) {
          console.error("Error notificando al host:", error);
          notificationStatus.textContent = "Error notificando al host";
          notificationStatus.className = "notification-badge error";
        }
      }

      function startCallStatusPolling() {
        // Polling cada 3 segundos para verificar estado
        const pollInterval = setInterval(async () => {
          if (isHostResponded || !callId) {
            clearInterval(pollInterval);
            return;
          }

          try {
            const response = await fetch(`/notifications/call-status/${callId}`);
            if (response.ok) {
              const data = await response.json();
              
              if (data.success && data.call) {
                const call = data.call;
                
                if (call.status === 'answered' && call.response === 'accept') {
                  // Host acept√≥ - iniciar WebRTC
                  isHostResponded = true;
                  clearInterval(pollInterval);
                  notificationStatus.textContent = "‚úÖ Host acept√≥ la llamada";
                  notificationStatus.style.backgroundColor = "#28a745";
                  initiateWebRTC();
                } else if (call.status === 'answered' && call.response === 'reject') {
                  // Host rechaz√≥
                  isHostResponded = true;
                  clearInterval(pollInterval);
                  handleHostRejection();
                } else if (call.status === 'timeout') {
                  // Timeout
                  isHostResponded = true;
                  clearInterval(pollInterval);
                  handleCallTimeout();
                }
              }
            }
          } catch (error) {
            console.log("Polling error:", error);
          }
        }, 3000);

        // Timeout general despu√©s de 60 segundos
        setTimeout(() => {
          if (!isHostResponded && !isCallActive) {
            clearInterval(pollInterval);
            handleCallTimeout();
          }
        }, 60000);
      }

      function setupSocketEvents() {
        socket.on("connect", () => {
          console.log("‚úÖ Conectado al servidor WebSocket");
          status.textContent = "Conectado - Llamando al host...";
        });

        socket.on("connect_error", (error) => {
          console.error("‚ùå Error de conexi√≥n WebSocket:", error);
          status.textContent = "Error de conexi√≥n - Intentando reconectar...";
        });

        // ‚úÖ ESCUCHAR RESPUESTA DEL HOST
        socket.on("call-response", (data) => {
          console.log("üì© Respuesta del host recibida:", data);
          
          if (data.callId === callId) {
            isHostResponded = true;
            
            if (data.response === 'accept') {
              // Host acept√≥
              notificationStatus.textContent = "‚úÖ Host acept√≥ la llamada";
              notificationStatus.style.backgroundColor = "#28a745";
              status.textContent = "Host conectado - Iniciando videollamada...";
              initiateWebRTC();
            } else if (data.response === 'reject') {
              // Host rechaz√≥
              handleHostRejection();
            }
          }
        });

        // ‚úÖ WEBRTC EVENTOS
        socket.on("offer", async (data) => {
          console.log("üì® Offer WebRTC recibida");
          if (!peerConnection) await initiateWebRTC();
          try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            socket.emit("answer", {
              answer,
              callId,
              targetUserId: data.from
            });
            
            console.log("üì§ Answer enviada");
          } catch (e) {
            console.error("Error procesando offer:", e);
          }
        });

        socket.on("answer", async (data) => {
          console.log("üì® Answer WebRTC recibida");
          if (peerConnection && !peerConnection.remoteDescription) {
            try {
              await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
              isCallActive = true;
              endCallButton.style.display = "block";
              status.textContent = "‚úÖ Videollamada conectada";
            } catch (e) {
              console.error("Error procesando answer:", e);
            }
          }
        });

        socket.on("ice-candidate", async (data) => {
          if (data.candidate && peerConnection) {
            try {
              await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (e) {
              console.log("ICE candidate ignorado:", e);
            }
          }
        });

        socket.on("call-ended", () => {
          console.log("üìû Llamada finalizada por el host");
          status.textContent = "Llamada finalizada por el host";
          endCall();
        });

        socket.on("call-connected", (data) => {
          console.log("‚úÖ Conexi√≥n establecida:", data);
          if (data.callId === callId) {
            status.textContent = "‚úÖ Conexi√≥n establecida con el host";
          }
        });

        socket.on("disconnect", () => {
          console.log("üîå Desconectado del servidor");
          if (isCallActive) {
            status.textContent = "Conexi√≥n perdida - Reconectando...";
          }
        });
      }

      async function initiateWebRTC() {
        if (peerConnection || isCallActive) return;
        
        console.log("üéØ Iniciando WebRTC...");
        connectionAttempts++;
        status.textContent = "Estableciendo conexi√≥n segura...";
        
        try {
          peerConnection = new RTCPeerConnection(pcConfig);
          isCallActive = true;

          // A√±adir tracks locales si existen
          if (localStream) {
            localStream.getTracks().forEach((track) => {
              peerConnection.addTrack(track, localStream);
            });
          }

          // Recibir stream del host
          peerConnection.ontrack = (event) => {
            console.log("üé• Stream del host recibido");
            if (event.streams && event.streams[0]) {
              remoteVideo.srcObject = event.streams[0];
              status.textContent = "‚úÖ Videollamada activa";
              endCallButton.style.display = "block";
            }
          };

          // Manejar conexi√≥n establecida
          peerConnection.onconnectionstatechange = () => {
            console.log("Estado conexi√≥n:", peerConnection.connectionState);
            if (peerConnection.connectionState === 'connected') {
              status.textContent = "‚úÖ Videollamada conectada";
            }
          };

          // Enviar ICE candidates
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              socket.emit("ice-candidate", {
                candidate: event.candidate,
                callId,
                targetUserId: hostId
              });
            }
          };

          // Crear y enviar offer
          const offer = await peerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });
          
          await peerConnection.setLocalDescription(offer);
          
          socket.emit("call-offer", {
            offer,
            roomId: callId,
            hostId: hostId,
            guestId: "web-guest"
          });
          
          console.log("üì§ Offer WebRTC enviada");
          status.textContent = "Conectando con el host...";

        } catch (error) {
          console.error("‚ùå Error iniciando WebRTC:", error);
          status.textContent = "Error de conexi√≥n";
          
          if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
            setTimeout(() => {
              if (!isCallActive) {
                console.log(`üîÑ Reintento ${connectionAttempts}/${MAX_CONNECTION_ATTEMPTS}`);
                initiateWebRTC();
              }
            }, 2000);
          } else {
            showError("No se pudo establecer la conexi√≥n. Intenta recargar la p√°gina.");
          }
        }
      }

      function handleHostRejection() {
        console.log("‚ùå Host rechaz√≥ la llamada");
        notificationStatus.textContent = "‚ùå Host rechaz√≥ la llamada";
        notificationStatus.style.backgroundColor = "#dc3545";
        status.textContent = "El host no est√° disponible en este momento";
        
        // Mostrar opci√≥n para dejar mensaje
        setTimeout(() => {
          waitingMessage.style.display = "block";
          notificationStatus.style.display = "none";
        }, 2000);
      }

      function handleCallTimeout() {
        console.log("‚è∞ Timeout de llamada");
        notificationStatus.textContent = "‚è∞ No hubo respuesta del host";
        notificationStatus.style.backgroundColor = "#ffc107";
        status.textContent = "El host no respondi√≥ a la llamada";
        
        // Mostrar opci√≥n para dejar mensaje
        setTimeout(() => {
          waitingMessage.style.display = "block";
          notificationStatus.style.display = "none";
        }, 2000);
      }

      async function sendMessageToHost() {
        const message = document.getElementById("guestMessage").value.trim();
        if (!message) {
          alert("Por favor escribe un mensaje");
          return;
        }

        try {
          const response = await fetch("/messages/send", {
            method: "POST",
            headers: { 
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              callId: callId,
              message: message
            })
          });

          if (response.ok) {
            alert("‚úÖ Mensaje enviado correctamente. Te contactaremos pronto.");
            closePage();
          } else {
            alert("‚ùå Error enviando mensaje");
          }
        } catch (error) {
          console.error("Error enviando mensaje:", error);
          alert("‚ùå Error de conexi√≥n");
        }
      }

      function endCall() {
        console.log("üìû Finalizando llamada...");
        isCallActive = false;
        
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
        
        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localStream = null;
        }
        
        if (socket) {
          socket.emit("end-call", { callId });
          socket.disconnect();
        }
        
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        endCallButton.style.display = "none";
        notificationStatus.style.display = "none";
        status.textContent = "Llamada finalizada";
        
        setTimeout(() => {
          window.close();
        }, 3000);
      }

      function closePage() {
        if (socket) {
          socket.emit("end-call", { callId });
          socket.disconnect();
        }
        window.close();
      }

      function showError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "notification-badge error";
        errorDiv.textContent = `‚ùå ${message}`;
        errorDiv.style.margin = "20px auto";
        errorDiv.style.display = "block";
        
        const container = document.querySelector(".container");
        container.appendChild(errorDiv);
        
        setTimeout(() => {
          errorDiv.remove();
        }, 5000);
      }

      // ‚úÖ EVENT LISTENERS
      endCallButton.addEventListener("click", endCall);

      window.addEventListener("beforeunload", () => {
        if (socket && callId) {
          socket.emit("end-call", { callId });
        }
      });

      // Detectar cuando el usuario intenta salir
      window.addEventListener("unload", () => {
        if (socket && callId) {
          // Enviar evento r√°pido antes de cerrar
          navigator.sendBeacon && navigator.sendBeacon(
            `${window.location.origin}/videocall/end-call`,
            JSON.stringify({ callId })
          );
        }
      });
    </script>
  </body>
</html>